import java.util.Comparator;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;

/**
 * This class orders the vertices of the queue used in MSTPrim based on the weights of its neighbors
 * @author rlopez
 *
 */
public class MSTPrimQueueComparator implements Comparator<Vertex> {
    // Graph graph;
//	public MSTPrimQueueComparator(Graph graph) {
//		this.graph = graph; 
//	}

    /**
     * Sorts from the minimum weight value of the neighbors of each vertex.
     * Algorithm:
     * If both vertices do not have neighbors then return 0
     * If one vertex has neighbor and the other does not then
     * 1) Finds the minimum weight for each of the neighbors for the first vertex
     * 2) Finds the minimum weight for each of the neighbors for the second vertex
     * 3) Returns
     *    -1 if the neighbor in the first vertex has the minimum value
     *    0 if the minimum values are the same
     *    1 if the first
     */
    @Override
    public int compare(Vertex v1, Vertex v2) {
        int minV1 = 0, minV2 = 0;
        if (v1.neighbors.size() != 0)
            minV1 = obtainMinimumWeight(v1.neighbors);
        if (v2.neighbors.size() != 0)
            minV2 = obtainMinimumWeight(v2.neighbors);
        return minV1 - minV2;
    }

    /**
     * Finds the minimum weight from a list of neighbors
     * @param neighbors
     * @return
     */
    private int obtainMinimumWeight(LinkedList<Neighbor> neighbors) {
        Neighbor firstNeighbor = neighbors.getFirst();
        Edge     minEdge       = firstNeighbor.edge;
        int      minWeight     = minEdge.weight;
        // Traverses the list to find the minimum
        for (Neighbor next : neighbors) {
            if (next.edge.weight < minWeight)
                minWeight = next.edge.weight;
        }
        return minWeight;
    } // end of obtainMinimumWeight
} // of MSTPrimQueueComparator
